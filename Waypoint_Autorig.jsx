function BuildUI(thisObj) {    var win = thisObj instanceof Panel ? thisObj : new Window("palette", "AutoRig", undefined, {        resizeable: true    });    win.lightRig = win.add("button", [10, 5, 80, 35], "Rig Setup");    win.lightRig.onClick = rigSetup;    win.layerRig = win.add("button", [85, 5, 150, 35], "Rig Layer");    win.layerRig.onClick = rigLayer;    win.targetAdd = win.add("button", [10, 40, 150, 70], "Remove Target");    win.targetAdd.onClick = removeTarget;    win.fixNames = win.add("button", [10, 75, 150, 105], "Fix Target Names");    win.fixNames.onClick = fixTargetNames;}// Insantiate the user interfaceBuildUI(this);// Globalsvar globalLightTargetsLayer;var globalCamCtrlLayer;function rigLayer() {    //var inertialBounce = "n = 0; if (numKeys > 0){n = nearestKey(time).index;if (key(n).time > time){ n--; } } if (n == 0){ t = 0; }else{ t = time - key(n).time; } if (n > 0){ v = velocityAtTime(key(n).time - thisComp.frameDuration/10); amp = .05; freq = 4.0; decay = 2.0; value + v*amp*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t); }else{ value; }"    app.beginUndoGroup("Rig Layer");    var curComp = app.project.activeItem;    var selLayers = curComp.selectedLayers;    var lightTargetsLayer;    var camCtrl;    // Find the light control layer     for (var i = 1; i <= curComp.numLayers; i++) {        if (curComp.layer(i).name == "Light Targets") {            lightTargetsLayer = curComp.layer(i);            break;        }    } // Find the cam control layer    for (var i = 1; i <= curComp.numLayers; i++) {        if (curComp.layer(i).name == "Camera CTRL") {            camCtrl = curComp.layer(i);            break;        }    }    if (camCtrl == null || lightTargetsLayer = null) {        alert("Could not find control layers! \n\n Exiting.");        return 1;    }    var sliderPresent = false;    if (selLayers[0].property("Effects").numProperties > 0) {        sliderPresent = false;        for (var i = 0; i < selLayers.length; i++) {            for (x = 1; x < selLayers[i].property("Effects").numProperties; i++) {                if (selLayers[i].property("Effects")(x).name == "Extrusion") {                    sliderPresent = true;                    break;                }            }        }    }    if (sliderPresent == false) {        for (var i = 0; i < selLayers.length; i++) {            var curEffect = selLayers[i].property("Effects").addProperty("ADBE Slider Control");            curEffect("Slider").expression = "clamp(thisProperty, 0, 100);"            curEffect.name = "Extrusion";            selLayers[i].position.expression = "master = thisComp.layer(\"Camera CTRL\").effect(\"Master Extrusion Depth\")(\"Slider\");\nctrl = effect(\"Extrusion\")(\"Slider\");\nx = thisProperty[0];\ny = thisProperty[1];\nz = linear(ctrl, 0, 100, -1, master*-1);\n[x,y,z]";        }    }    app.endUndoGroup();}function rigSetup() {    app.beginUndoGroup("Rig Lights");    var curComp = app.project.activeItem;    // Create the ambient Light    var ambLight = curComp.layers.addLight("Ambient Light", [0, 0]);    ambLight.position.setValue([curComp.width / 2, curComp.height / 2, 500]);    ambLight.lightType = LightType.AMBIENT;    // Create the point light    var pntLight = curComp.layers.addLight("Point Light", [0, 0]);    pntLight.position.setValue([curComp.width / 2, curComp.height / 2, -500]);    pntLight.lightType = LightType.POINT;    // The Point light must cast shadows    pntLight.lightOption.castsShadows.setValue(1);    // Up the shadow diffusion    pntLight.lightOption.shadowDiffusion.setValue(70.0);    pntLight.lightOption.property("Falloff").setValue(3);    pntLight.lightOption.property("Shadow Darkness").setValue(50);    pntLight.lightOption.property("Radius").setValue(500);    // Create the camera    var theCamera = curComp.layers.addCamera("Main Cam", [curComp.width / 2, curComp.height / 2]);    theCamera.position.setValue([curComp.width / 2, curComp.height / 2, theCamera.position.value[2]]);    // Create the camera parent    var camParent = curComp.layers.addNull();    camParent.name = "Camera Parent Null";    camParent.threeDLayer = true;    camParent.position.setValue([curComp.width / 2, curComp.height / 2, 0]);    // Create the camera controls    var camCtrl = camParent.duplicate();    camCtrl.name = "Camera CTRL";    // GLOBAL    globalCamCtrlLayer = camCtrl;    // Expressions!    camParent.position.expression = "x = thisComp.layer(\"Camera CTRL\").transform.position[0]; y = thisComp.layer(\"Camera CTRL\").transform.position[1]; z = 0; [x,y,z];";    camParent.transform.orientation.expression = "thisComp.layer(\"Camera CTRL\").transform.orientation";    camParent.transform.xRotation.expression = "thisComp.layer(\"Camera CTRL\").transform.xRotation";    camParent.transform.yRotation.expression = "thisComp.layer(\"Camera CTRL\").transform.yRotation";    camParent.transform.zRotation.expression = "thisComp.layer(\"Camera CTRL\").transform.zRotation";    // Parent up the camera    theCamera.parent = camParent;    // Place the control expression on the camera    theCamera.position.expression = "ctrl = thisComp.layer(\"Camera CTRL\").transform.position[2]; [thisProperty[0], thisProperty[1], thisProperty[2] + ctrl];";    // Move the camera and camera parent to the end of the layer stack    camParent.moveToEnd();    theCamera.moveToEnd();    // Make the camera and camera parent shy    theCamera.shy = true;    camParent.shy = true;    // Lock the camera and camera parent    theCamera.locked = true;    camParent.locked = true;    /////////////// DIMMER  ///////////////    // Create an effect to control dimming    var dimmerSlider = camCtrl.property("Effects").addProperty("ADBE Slider Control");    dimmerSlider.name = ("Light Dimmer")    // Reassign the variable to grab tha actual slider    dimmerSlider = dimmerSlider.property("Slider");    // Clamp the range    dimmerSlider.expression = "clamp(thisProperty, 0,100);"    // Create an effect to control the master extrusion level    var masterExtrusion = camCtrl.property("Effects").addProperty("ADBE Slider Control");    masterExtrusion.name = "Master Extrusion Depth";    masterExtrusion.property("Slider").setValue(200);    // Create an effect to control the current position of the light    var lightPositionCtrl = camCtrl.property("Effects").addProperty("ADBE Slider Control");    lightPositionCtrl.property("Slider").setValue(1.0);    lightPositionCtrl.name = "Light Position";    lightPositionCtrl.property("Slider").expression = "Math.round(thisProperty)";    // Create an effect to control whether or not to interpolate between points    var interpCtrl = camCtrl.property("Effects").addProperty("ADBE Checkbox Control");    interpCtrl.name = "Interpolation";    interpCtrl.property("Checkbox").setValue(0);    // Now that the dimmer is set up, create the expressions on the lights.    pntLight.lightOption.intensity.expression = "linear(thisComp.layer(\"Camera CTRL\").effect(\"Light Dimmer\")(\"Slider\"), 0, 100, 0, 100)";    ambLight.lightOption.intensity.expression = "linear(thisComp.layer(\"Camera CTRL\").effect(\"Light Dimmer\")(\"Slider\"), 0, 100, 100, 20)";    // Create a "Light Targets" layer to hold the sequencing of the lights.     var lightTargetsLayer = curComp.layers.addNull();    lightTargetsLayer.name = "Light Targets";    var firstTarget = lightTargetsLayer.property("Effects").addProperty("ADBE Layer Control");    firstTarget.name = "Target 1";    // GLOBAL    globalLightTargetsLayer = lightTargetsLayer;    // ...And now the Waypoint expression on the position of the the point light. Defined below because that     var waypointExp = "l = thisComp.layer(\"Light Targets\");\nl2 = thisComp.layer(\"Camera CTRL\");\ncurLightCtrl = l2.effect(\"Light Position\")(\"Slider\");\nz = thisProperty[2];\n\nvar d = false;\nvar numTargets = 0;\nwhile (d == false) {\n    try {\n        numTargets++;\n        t = l.effect(numTargets);\n    } catch (err) {\n        numTargets = numTargets - 1;\n        d = true;\n    }\n}\nvar waypoints = new Array();\nwaypoints.push([thisComp.width / 2, thisComp.height / 2]);\n\nvar curLayer = null;\nfor (var i = 1; i < numTargets + 1; i++) {\n    curLayer = l.effect(i)(\"Layer\");\n    waypoints.push([curLayer.position[0], curLayer.position[1]]);\n}\nif (curLightCtrl.numKeys > 0) {\n    nk = curLightCtrl.nearestKey(time);\n    if (nk.time >= time) {\n        if (nk.index == 1) {\n            prevKey = nk;\n            nextKey = nk;\n        } else {\n            prevKey = curLightCtrl.key((nk.index) - 1);\n            nextKey = nk;\n        }\n    } else {\n        prevKey = nk;\n        try {\n            nextKey = curLightCtrl.key(nk.index + 1);\n        } catch (err) {\n            nextKey = nk;\n        }\n    }\n    /* \n    The following try/catch statemnts attempt to set the lower and upper limits of the linear conversion\n    In the event of an error, the min values default to waypoints[0][x], and the upper limits default to \n    waypoints[waypoints.length-1][x]. Look at us, all clever and shit. \n    */\n    var xmin, xmax, ymin, ymax = null;\n    var minIndex, maxIndex = null;\n\n    var prevKeyValue = Math.round(prevKey.value);\n    var nextKeyValue = Math.round(nextKey.value);\n\n    minIndex = clamp(prevKeyValue, 0, numTargets);\n    maxIndex = clamp(nextKeyValue, 0, numTargets);\n    var userInterpolate = l2.effect(\"Interpolation\")(\"Checkbox\");\n    if (userInterpolate == 1) {\n        x = linear(time, prevKey.time, nextKey.time, waypoints[minIndex][0], waypoints[maxIndex][0]);\n        y = linear(time, prevKey.time, nextKey.time, waypoints[minIndex][1], waypoints[maxIndex][1]);\n    }\n    else {\n        x = waypoints[minIndex][0];\n        y = waypoints[minIndex][1];\n    }\n    [x, y, z];\n} else {\n    try {\n        x = waypoints[1, 0];\n        y = waypoints[1, 1];\n        [x, y, z]\n    } catch (err) {\n        x = thisComp.width / 2;\n        y = thisComp.height / 2;\n        [x, y, z];\n    }\n    thisProperty;\n}";    pntLight.position.expression = waypointExp;    app.endUndoGroup();};function removeTarget() {    app.beginUndoGroup("Remove Target");    // Boilerplate         var curComp = app.project.activeItem;    var selLayers = curComp.selectedLayers;    var lightTargetsLayer = null;    var camCtrl;    // Find the light control layer     for (var i = 1; i <= curComp.numLayers; i++) {        if (curComp.layer(i).name == "Light Targets") {            lightTargetsLayer = curComp.layer(i);            $.writeln("Found light targets layer, " + lightTargetsLayer.name);            break;        }    }    // Find the cam control layer    for (var i = 1; i <= curComp.numLayers; i++) {        if (curComp.layer(i).name == "Camera CTRL") {            camCtrl = curComp.layer(i);            break;        }    }    if (camCtrl == null || lightTargetsLayer == null) {        alert("Could not find control layers! \n\n Exiting.");        return 1;    }    if (selLayers[0] != lightTargetsLayer) {        alert("You must select a target in the Light Targets effects bin!\n err 01");        return 1;    }    if (selLayers.length > 1) {        alert("You must select a target in the Light Targets effects bin! \n err 02");        return 1;    }    if (selLayers[0].selectedProperties.length != 1) {        alert("You must select one and only one target layer to remove at a time."); {            return 1;        }    }    // Workaround for the face that we were losing the definition of lightTargetsLayer. Scope prolblem maybe?    lightTargetsLayer = curComp.selectedLayers[0];    // Find out how many layers we have in the bin    var numEffects = app.project.activeItem.selectedLayers[0].property("Effects").numProperties;    // Pull the index, which is reall just the tail end of the target name.     var targetEffect = curComp.selectedLayers[0].selectedProperties[0];    var targetEffectIndex = targetEffect.name;    targetEffectIndex = targetEffectIndex.split(" ");    targetEffectIndex = parseInt(targetEffectIndex[1]);    // Remove the target effect    targetEffect.remove();    // Loop through the effects left over. If their index was higher than the one we deleted, know their names down by one.    // Start at target effect index, everything after this point will need to be adjusted    for (var i = targetEffectIndex; i < numEffects; i++) {        var curEffect = lightTargetsLayer.property("Effects").property(i);        curEffect.name = "Target " + i;    }    var lightPosTrack = camCtrl.property("Effects").property("Light Position")("Slider");    // Grab all the keys in the "light position" field    for (var i = 1; i <= camCtrl.property("Effects").property("Light Position")("Slider").numKeys; i++) {        // Keyframes are 1-indexed        if (Math.round(lightPosTrack.keyValue(i)) == targetEffectIndex) {            lightPosTrack.removeKey(i)        }        if (Math.round(lightPosTrack.keyValue(i)) > targetEffectIndex) {            var targetTime = lightPosTrack.keyTime(i);            var originalValue = lightPosTrack.keyValue(i);            lightPosTrack.setValueAtTime(targetTime, originalValue - 1);        }    }    app.endUndoGroup();}function fixTargetNames() {    app.beginUndoGroup("Fix Target Names");    // Boilerplate     var curComp = app.project.activeItem;    var selLayers = curComp.selectedLayers;    var lightTargetsLayer = null;    // Find the light control layer     for (var i = 1; i <= curComp.numLayers; i++) {        if (curComp.layer(i).name == "Light Targets") {            lightTargetsLayer = curComp.layer(i);            //$.writeln("Found light targets layer, " + lightTargetsLayer.name);            break;        }    }    // Exit if we can't find the layer list    if (lightTargetsLayer == null) {        alert("Could not find Light Targets layer. \nExiting execution");        return 1;    }    // Find out how many effects we need to loop through    var numEffectLayers = lightTargetsLayer.property("Effects").numProperties;    // Cycle through and update the names approptiately     for (var i = 1; i <= numEffectLayers; i++) {        var curEffect = lightTargetsLayer.property("Effects")(i);        var targetName = "Target " + i;        curEffect.name = targetName;    }    app.endUndoGroup();}function addTarget() {    app.beginUndoGroup("Add Targets");    // Boilerplater     var curComp = app.project.activeItem;    var selLayers = curComp.selectedLayers;    var selLayersBackup = curComp.selectedLayers;    var lightTargetsLayer;    // Find the light control layer     for (var i = 1; i <= curComp.numLayers; i++) {        if (curComp.layer(i).name == "Light Targets") {            lightTargetsLayer = curComp.layer(i);            break;        }    }    // Exit if target cannot be found    if (lightTargetsLayer == null) {        alert("Could not find control layers! \n\n Exiting.");        return 1;    }    // Determine the number to start at    var numTargets = lightTargetsLayer.property("Effects").numProperties;    // Loop through each selected layer in order and add them to the the target layers panel    for (var i = 0; i < selLayers.length; i++) {        var targetName = "Target " + (numTargets + i + 1);        var curLayerEffect = selLayers[i].property("Effects").addProperty("ADBE Layer Control");        curLayerEffect.name = targetName;        // Some UI Scripting to copy the layer effect to the target layers Panel        //ightTargetsLayer.property("Effects").addProperty(curLayerEffect);    }    app.endUndoGroup();}